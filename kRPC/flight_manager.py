import init_simulation
from plane_error import plane_error
from flight_sim_3d import flight_sim_3d, UPFGControl
from results_to_init import results_to_init

R = init_simulation.R


def strip_trailing_empty(items):
    entries = list(items)
    while len(entries) > 0 and entries[-1] is None:
        entries.pop()
    return entries


class Flight:
    def __init__(self, powered, coast, n):
        self.powered = powered
        self.coast = coast
        self.n = n


def flight_manager(vehicle, init, target, dt, s1guidance, upfg_cycle, coast_length, events, apply_guidance_func=None, get_state_func=None):
    """
    Flight simulation for the entire vehicle. FlightSim3D only handles one
    stage - flightManager consecutively calls flightSim3D for each stage,
    until a target is reached (or a failure is detected). Outputs aggregated
    results from the entire flight.
    Assumption is that the first stage is controlled with either a pitch
    program or a simple gravity turn (ie. anything that is not active guidance)
    and remaining stages are collectively guided with a multistage UPFG.
    Supports variable coast phases' lengths and minor jettison events.
    
    :param vehicle: Array of VehicleStage defining the entire vehicle.
    :param init: Initial conditions struct, preferrably a launch site.
    :param target: Target for UPFG (as generated by launch_targeting).
    :param dt: Simulation precision (seconds).
    :param s1guidance: Control struct to be used on the first stage.
    :param upfg_cycle  UPFG cycle length (guidance will called this often) (seconds).
    :param coast_length: Coast phase length. Two possibilities here:
        a single float - a coast phase of this length will occur
        between each powered phase (zero means no coasts at all),
        array of floats - list of coast phase lenghts to occur
        between consecutive powered phases; if this list is
        shorter than needed, last value will be used repeatedly.
        Values are in seconds.
    :param events: Array of minor jettison events (can be empty). See entry in
        flightSim3D for details.
    :return: Results struct, packed into a superstructure for easy
        extraction of data and visualization. Will contain results
        (as returned by flight_sim_3d) packed into two arrays:
        results.powered - all consecutive powered phases
        results.coast - all coast phases (this might be empty)
        Additionally will contain an .n field, which is an int
        equal to length(results.powered).
    """
    global R  # Global variable, radius of the body (m).

    n = len(vehicle)
    coast = [None]*n
    powered = [None]*n
    # Handle first stage first, as it's guided with a separate scheme and outputs different results struct.
    powered[0] = flight_sim_3d(vehicle, 0, init, s1guidance, events, dt, apply_guidance_func, get_state_func)
    # Create UPFG handler
    upfg_control = UPFGControl(target, upfg_cycle)
    # If coast length was given by a single number, we will create an ad-hoc
    # array, so the rest of the code was more unified.
    if not isinstance(coast_length, list):
        coast_length = [coast_length]*n
    # If less coasts lengths were passed than needed (n-1 for n stages),
    # will replicate the last element enough times.
    elif len(coast_length) < n-1:
        for i in range(len(coast_length), n-1):
            coast_length.append(coast_length[len(coast_length)-1])
    # Separate iterator for coast phases - if some are zero-long, their
    # structs will not be created, so they and powered stages will be uneven.
    c = 0
    # Handle the rest of the flight in a loop
    for i in range(1, n):
        # If then next coast period has non-zero length, handle it and
        # continue the flight. Otherwise just fly a powered phase from the
        # last one.
        if coast_length[i-1] > 0:
            # Iterate coast phases.
            coast_control = coast_control(coast_length[i-1])
            c = c + 1
            coast[c-1] = flight_sim_3d(vehicle, i, results_to_init(powered[i-1]), coast_control, events, dt, apply_guidance_func, get_state_func)
            powered[i] = flight_sim_3d(vehicle, i, results_to_init(coast[c-1]), upfg_control, events, dt, apply_guidance_func, get_state_func)
        else:
            powered[i] = flight_sim_3d(vehicle, i, results_to_init(powered[i-1]), upfg_control, events, dt, apply_guidance_func, get_state_func)
        # If a powered stage was cut off by the guidance algorithm - do not
        # simulate any more stages.
        if powered[i].eng > 1 and i < n-1:
            n = len(strip_trailing_empty(powered))
            print('Used less stages than available (%d of %d).' % (i+1, len(vehicle)))
            break
        # Support crash detection
        if powered[i].eng < -10:
            print('Critical mission failure. Vehicle crashed (stage %d).' % i)
            break

    # Output a struct and do some printouts
    flight = Flight(strip_trailing_empty(powered), strip_trailing_empty(coast), n)
    if powered[n-1].eng > 1:
        print('Successful insertion at T+%.1f into %.1fx%.1fkm, %.1f degree orbit' % (max(flight.powered[n-1].plots.t), flight.powered[n-1].periapsis, flight.powered[n-1].apoapsis, flight.powered[n-1].orbit.inc))
        print('Final conditions error: %.3f (angle), %.3f (eccentricity), %.3f (altitude)' % (plane_error(flight, target), flight.powered[n-1].orbit.ecc, abs((target.radius-R)/1000 - flight.powered[n-1].altitude)))
    else:
        print('Mission failure with ENG code %d.' % flight.powered[n-1].eng)
    return flight
